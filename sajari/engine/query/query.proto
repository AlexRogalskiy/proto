syntax = "proto3";

package sajari.engine.query;

import "sajari/engine/value.proto";
import "sajari/engine/status.proto";
import "sajari/engine/key.proto";

// Service Query defines methods for querying an engine collection.
service Query {
  // Search takes a search request and returns a corresponding response containing.
  // the search results and additional information on the search.
  rpc Search (SearchRequest) returns (SearchResponse);

  // Evaluate takes a search request and a document and runs the search against
  // the document only.
  rpc Evaluate (EvaluateRequest) returns (SearchResponse);

  // Substitute takes a search request and a document and substitutes the document values
  // in the request.
  rpc Substitute (SubstituteRequest) returns (SearchRequest);

  // Analyse takes an AnalyseRequest (comprised of a search query and a document identifier) and computes
  // the term overlap between the two.
  rpc Analyse (AnalyseRequest) returns (AnalyseResponse);
}

// SearchRequest encompasses all the parameters necessary to query a search index.  Search requests
// allow callers to select documents from a collection and return them in a score-based
// ordering.
//
// Documents in the search index can be queried/scored using a combination of:
// 1. Field values (key-value pairs set by the user).  See Filter, FieldBoost, Sort.
// 2. Terms (extracted from the body of the document, or from string-based indexed fields).
//    See Body, Terms, InstanceBoost.
//
// Quering a search index follows three main steps:
// 1. Selecting potentially suitable documents to include in a result set.
// 2. Ranking and sorting the documents based on configurable scoring and/or sorting rules.
// 3. Computing aggregate statistical information from the result set.
message SearchRequest {
  // Body is a list of weighted free text.
  repeated Body body = 1;

  // Terms is a list of weighted terms, where terms represent tokenised sequences of text.
  repeated Term terms = 2;

  // Filter is rule which is checked against a document's meta values.
  //
  // Only documents that match the filter will be included in the result.
  Filter filter = 3;

  // FieldBoosts are a list of rules checked against a document's field values.
  //
  // Field boosting allows callers to boost documents which have field values that
  // match a rule.
  repeated FieldBoost field_boosts = 4;

  // InstanceBoosts are a list of rules checked against a document's term instances.
  //
  // Instance boosting allows callers to boost documents which have terms that match
  // a rule.
  repeated InstanceBoost instance_boosts = 5;

  // Page number of results to return.
  int32 page = 6;

  // Number of results to return per page.
  int32 results_per_page = 7;

  // Fields to be returned for each result in the results. If empty then all fields are returned.
  repeated string fields = 8;

  // Sort ordering applied to results. Multiple sorts can be applied sequentially. If set, this
  // overrides the default score ordering of results.
  repeated Sort sort = 9;

  // A set of Aggregates to be run on the result set.
  map<string, Aggregate> aggregates = 10;

  // Transforms to be applied to the request before it is run.
  repeated Transform transforms = 11;
}

// Transform is a transformation of the search request to be applied before
// the search is run. Transforms are typically used to extract additional
// features or to augment the input query itself.
message Transform {
  string identifier = 1;
}

// Term represents a tokenized piece of text (i.e. a single word, or number) and is the lowest level
// of index-based query input that can be specified.
message Term {
  // Term string value
  string value = 1;

  // Field that the term originated from.
  string field = 2;

  // Number of positive interactions (uint16) this Term instance has been involved with.
  uint32 pos = 3;

  // Number of negative interactions (uint16) this Term instance has been involved with.
  uint32 neg = 4;

  // Significance of the term (uint16).
  double weight = 5;

  // Word offset (context) (uint16). This indicates the position of this term instance
  // relative to other terms in a body string
  uint32 word_offset = 6;

  // Paragraph offset (context) (uint16). This indicates the paragraph position (a grouping
  // of term instances) for this term instance in a body string. Useful for larger bodies
  // of text
  uint32 para_offset = 7;
}

// EvaluateRequest contains all parameters necessary to make an Evaluate call.
message EvaluateRequest {
  // Search request to run.
  SearchRequest search_request = 1;

  // Document to search against.
  map<string, bytes> document = 2;
}

message SubstituteRequest {
  // Request is used as a template
  SearchRequest search_request = 1;

  // Document is the document to be substituted in the request.
  map<string, bytes> document = 2;
}

// Body is a weighted free text query.
message Body {
  // Text (free text).
  string text = 1;

  // Weight (importance) to apply to this text.
  // This value must be 0 <= weight <= 1 but must be set. A value of zero means
  // the text has no value.
  double weight = 2;
}

// Aggregate is a statistical query run on the result set of a search.
message Aggregate {
  // Metric calculates numerical information from a field.
  message Metric {
    // Name of the field to run numerical metrics.
    string field = 1;

    // Enumeration of metric types.
    enum Type {
      // Average field value.
      AVG = 0;
      // Minimum field value.
      MIN = 1;
      // Maximum field value.
      MAX = 2;
      // Sum of all field values.
      SUM = 3;
    }

    // The type of metric to apply.
    Type type = 2;
  }

  // Count records the number of unique values for a field.
  message Count {
    // Name of the field to count values from.
    string field = 1;
  }

  // Bucket groups documents using filters, Documents which satisfy the filter
  // will be included in the bucket.
  message Bucket {
    // Bucket represents documents which satisfy a Filter.
    message Bucket {
      // Name of the bucket.
      string name = 1;

      // Filter satisfied by documents in the bucket.
      Filter filter = 2;
    }

    // List of buckets.
    repeated Bucket buckets = 1;
  }

  oneof aggregate {
    Metric metric = 1;
    Count count = 2;
    Bucket bucket = 3;
  }
}

// Sort defines the ordering of result documents using field values.
message Sort {
  // Field to take values from.
  string field = 1;

  // Order is an enumeration that defines orderings for sorting.
  enum Order {
    // Ascending: from least to greatest, for non-numeric
    // fields this means alphabetical order.
    ASC = 0;

    // Descending: from greatest to least, for non-numeric
    // fields this means reverse-alphabetical order.
    DESC = 1;
  }

  // Sorting order.
  Order order = 2;
}

// Filter describes a set of conditions to match values in document fields.
// Filters can be nested and combined using Combinators.
message Filter {
  // Field is a filter which is applied to a document field.
  message Field {
    // Operator is an enumeration of operators.
    enum Operator {
      // Equal value.  For STRING fields this is case insensitive.
      EQUAL_TO = 0;
      
      // Not equal value.  For STRING fields this is case insensitive.
      NOT_EQUAL_TO = 1;

      GREATER_THAN = 2;
      GREATER_THAN_OR_EQUAL_TO = 3;
      LESS_THAN = 4;
      LESS_THAN_OR_EQUAL_TO = 5;

      // For STRING fields this is case insensitive.
      CONTAINS = 6;

      // For STRING fields this is case insensitive.
      DOES_NOT_CONTAIN = 7;

      // For STRING fields this is case insensitive.
      HAS_SUFFIX = 8;

      // For STRING fields this is case insensitive.
      HAS_PREFIX = 9;
    }

    // The comparison operator to use.
    Operator operator = 1;

    // Field to take values from.
    string field = 2;

    // Value to match against.
    Value value = 3;
  }

  // Geo is a geo-based filter for documents with lat/lng fields representing a location.
  message Geo {
    // Field containing latitude (degrees).
    string field_lat = 1;

    // Field containing longitude (degrees).
    string field_lng = 2;

    // Target latitude (in degrees).
    double lat = 3;

    // Target longitude (in degrees).
    double lng = 4;

    // Radius (in km) of matching border (see region).
    double radius = 5;

    // Region is an enumeration that defines regions for geo-boosting.
    enum Region {
      // Inside is used to configure a geo filter to be
      // satisfied on all points within the radius.
      INSIDE = 0;

      // Outside is used to configure a geo filter to be
      // satisfied to all points outside the radius.
      OUTSIDE = 1;
    }

    // Region for matching points.
    Region region = 6;
  }

  // Combinator is a filter which combines other filters.
  message Combinator {
    // Operator is an enumeration of combination operators.
    enum Operator {
      // All of the filters must be satisfied.
      ALL = 0;

      // Any of the filters must be satisfied.
      ANY = 1;

      // One of the filters (and only one) must be satisfied.
      ONE = 2;

      // None of the filters must be satisfied.
      NONE = 3;
    }

    // The operator used to combine filters.
    Operator operator = 1;

    // The set of filters to combine using the specified Operator.
    repeated Filter filters = 2;
  }

  oneof filter {
    Combinator combinator = 1;
    Field field = 2;
    Geo geo = 3;
  }
}

// FieldBoost is used to influence the score of a document based on its field values.
//
// The effect of a FieldBoost is the value that it contributes to the overall score.
// All boost effects are between 0 and 1 inclusive.
//
// Wrap a FieldBoost in an AdditiveFieldBoost to make it contribute to a
// proportion of the overal score instead of multiplying the existing score.
message FieldBoost {
  // Additive is a FieldBoost wrapper which makes the boost value represent
  // a proportion of the overall score instead of scaling the existing
  // score.
  message Additive {
    // FieldBoost to make additive.
    sajari.engine.query.FieldBoost field_boost = 1;

    // Amount this boost will contribute to the overall score of the document.
    //
    // Must be between 0 and 1.
    double value = 2;
  }

  // Filter is a boost applied to documents which satisfy the filter.
  message Filter {
    // Filter which must be satisfied by document.
    sajari.engine.query.Filter filter = 1;

    // Boost value to apply to matching documents. Must be >= 0.
    //
    // Value == 0     Matching documents get 0 for this boost, everything else gets 1.
    // Value == 1     Matching documents get 1 for this boost, everything else gets 0.
    // 0 < Value < 1  Matching documents get Value for this boost (and are penalised).
    // Value > 1      Matching documents get 1 for this boost, everything else gets 1 / Value.
    double value = 2;
  }

  // Interval is a distance-based boosting for numeric fields.
  //
  // It is comprised of a series of points to represent
  // any linear distribution across a numerical range.
  message Interval {
    // Point is a pair (point, value) which defines the boost value
    // at a particiular point.
    message Point {
      // The point to mark the beginning/end of an interval.
      double point = 1;

      // The amount to boost by at this Point.
      double value = 2;
    }

    // Numerical field to apply the boost.
    string field = 1;

    // Points which define intervals boundaries (must be at least 2).
    // Values between internal points are determined linearly.
    repeated Point points = 2;
  }

  // Distance is a distance-based boosting for numeric fields.
  //
  // It defines a reference point within a interval defined by a min and max value.
  // The boost is then applied to values which fall in the min-max interval and is
  // evaluated based on the distance to the reference point.
  //
  // Boost effect: between 0 and 1.
  message Distance {
    // Minimum distance from the ref point.
    double min = 1;

    // Maximum distance from the ref point.
    double max = 2;

    // Reference value to compare against.
    double ref = 3;

    // Numerical field to apply the boost.
    string field = 4;

    // Value to apply to points inside the min-max range.
    double value = 5;
  }

  // Element is an element-based boost for repeated fields.
  //
  // The boost is evaluated as a portion of a list of values which appear
  // in the document field.
  //
  // Boost effect: between 0 and 1.
  message Element {
    // Field containing stringArray.
    string field = 1;

    // List of elements to compare against the field values.
    repeated string elts = 3;
  }

  // Text represents a text-based boosting for string fields.
  //
  // Compares text (using a bag of words model) and applies a boost based on the
  // number of intersecting words.
  //
  // Boost effect: between 0 and 1.
  message Text {
    // Field containing string data.
    string field = 1;

    // Text to compare against the field value.
    string text = 3;
  }

  oneof field_boost {
    Additive additive = 1;
    Filter filter = 2;
    Interval interval = 3;
    Distance distance = 4;
    Element element = 5;
    Text text = 6;
  }
}

// InstanceBoost represents a boosting which is a applied to instances of terms
// in the reverse index.  This type of boost effectively dynamically ranks
// documents for a given term
message InstanceBoost {
  // Field is an instance boost which is applied to term instances which originate
  // from the given meta field.
  message Field {
    // Field where the term instance was defined.
    string field = 1;

    // Value to boost terms from this field. A value between 0 and 1 will decrease
    // the score, a value greater than 1 will increase the score.
    double value = 2;
  }

  // Score is an instance boost that boosts term instances based on their individual
  // scores based on individual interactions.
  message Score {
    // Threshold defines the maximum value to allow.  This is used to scale and cap
    // the computed score.
    double threshold = 1;

    // MinCount is the minimum number of interactions required to enable scoring.
    uint32 min_count = 2;
  }

  oneof instance_boost {
    Field field = 1;
    Score score = 2;
  }
}

// AggregateResponse contains statistical information representing aggregation results
message AggregateResponse {
  // Metric represents the metric type requested, represented by an Enumeration Type.
  message Metric {
    double value = 1;
  }
  // Count contains the counts for the set of values returned
  message Count {
    map<string, int32> counts = 1;
  }

  // Buckets is a full set of buckets computed in an aggregation.
  message Buckets {
    // Bucket is the result of a bucket aggregate.
    message Bucket {
      // Name of bucket.
      string name = 1;
      // Number of documents in the bucket.
      int32 count = 2;
    }
    map<string, Bucket> buckets = 1;
  }

  oneof aggregate_response {
    Metric metric = 1;
    Count count = 2;
    Buckets buckets = 3;
  }
}

// SearchResponse contains all data in response to a search request.
message SearchResponse {
  // Number of reverse indexes read during the search request.
  int64 reads = 1;

  // Total number of results.
  int64 total_results = 2;

  // Time taken to perform query.
  string time = 3;

  // Aggregates returned by query.
  map<string, AggregateResponse> aggregates = 4;

  // Results returned by query.
  repeated Result results = 5;
}

// Result is a document as represented in a search result.
message Result {
  // Meta data in field-value pairs.
  map<string, Value> values = 1;

  // Score (normalised) attributed to this document by the raw_score and boosting components.
  double score = 2;

  // Raw score attributed to this document by the query reverse index intersections.
  double raw_score = 3;
}

// AnalyseRequest applies a search request to a document.
message AnalyseRequest {
  // Request is a search request which should be applied against a document
  // in the store.
  SearchRequest search_request = 1;

  // Key is a unique identifier corresponding to a document in the store.
  repeated sajari.engine.Key keys = 2;
}

// AnalyseResponse contains the analysis of the document against the query
// request.
message AnalyseResponse {
  // Terms is a list of terms which overlap for a particular document.
  message Terms {
    repeated string terms = 1;
  }

  // Terms is the list of intersecting terms between the document and the
  // search query request.
  repeated Terms terms = 1;

  // Status corresponding to each key in the request.
  repeated Status status = 2;
}
